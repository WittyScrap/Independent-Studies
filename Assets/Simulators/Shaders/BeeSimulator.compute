#pragma kernel CSSimulate
#pragma kernel CSDissipate


/** Structures */

#define Inertia .5f
#define MaxNeighbours 15
#define MaxOptions 5
#define MovementSpeed 1.f

//
//  Represents a single particle for the Particle Swarm Optimisation
//  based algorithm.
//
struct Particle
{
    float2 position;
    float2 velocity;
    int    preference;
    float  strength;
};

//
// Tracks which particle has expressed preference for which
// option and by how much.
//
struct OptionTracker
{
    float strength;
    int participants;
};

/** Data */

RWTexture2D<float3>             ParticleSpace;
RWStructuredBuffer<Particle>    Particles;
StructuredBuffer<float4>        Options;
StructuredBuffer<float4>        OptionsColors;

int ParticlesCount;
int OutputWidth;
int OutputHeight;
int Step;
float CommsDistance;
float SpawnRadius;


/** Functions */ 


float random(in float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

void plot(in float2 where, in float4 color)
{
    const float partcileAdd = 0.5f;
    const int radius = 3;

    ParticleSpace[where] += partcileAdd * 2;

    for (int x = where.x - radius; x < where.x + radius; x += 1)
    {
        for (int y = where.y - radius; y < where.y + radius; y += 1)
        {
            ParticleSpace[int2(x, y)] += color.rgb * (partcileAdd * (1 - (length(float2(x, y) - where) / (float)radius)));
        }
    }
}

float2 iIf(bool _condition, float2 _true, float2 _false)
{
    return (_condition * _true) + (!_condition * _false);
}

/** Kernels */

// PSO kernel
// 
// Runs the Particle Swarm Optimisation algorithm.
[numthreads(512,1,1)]
void CSSimulate (uint3 id : SV_DispatchThreadID)
{
    Particle particle = Particles[id.x];
    plot(particle.position, OptionsColors[particle.preference]);

    int i;
    OptionTracker optionTrackers[MaxOptions];

    for (i = 0; i < MaxOptions; i += 1)
    {
        optionTrackers[i].strength = 0;
        optionTrackers[i].participants = 0;
    }

    {
        int neighbours[MaxNeighbours];
        int neighboursCount = 0;

        for (i = 0; i < MaxNeighbours; i += 1)
        {
            neighbours[i] = 0;
        }

        // Find nearby particles and save them as neighbours

        for (i = 0; i < ParticlesCount && neighboursCount < MaxNeighbours; i += 1)
        {
            if (length(Particles[i].position - particle.position) < CommsDistance)
            {
                neighbours[neighboursCount] = i;
                neighboursCount += 1;
            }
        }

        // Observe broadcast preference and its weight, tally up a count of which option
        // is the most preferred in the nearby area.

        float2 seeder = particle.position.yx;

        for (i = 0; i < neighboursCount; i += 1)
        {
            float strength = Particles[neighbours[i]].strength + random(seeder);
            optionTrackers[Particles[neighbours[i]].preference].strength += strength;
            optionTrackers[Particles[neighbours[i]].preference].participants += 1;

            seeder = (seeder * strength * 2 - 1.f).yx;
        }
    }

    optionTrackers[particle.preference].strength += particle.strength;
    optionTrackers[particle.preference].participants += 1;

    // Pick best value, convert to it - if the best value ends up being the same as what we had, a no-conversion case
    // will be observed.

    int bestOption = 0;

    for (i = 0; i < MaxOptions; i += 1)
    {
        if (optionTrackers[i].strength > optionTrackers[bestOption].strength)
        {
            bestOption = i;
        }
    }

    particle.preference = iIf(Step > 0, bestOption, particle.preference);
    particle.strength = optionTrackers[bestOption].strength / (float)optionTrackers[bestOption].participants;

    // Pick a random point to fly towards, or fly towards the agreed answer

    float x = random(particle.position.xy + particle.velocity.yx) * 2 - 1;
    float y = random(particle.position.yx + particle.velocity.xy) * 2 - 1;

    float2 target = (float2(x, y) * SpawnRadius * 20) + (float2(OutputWidth, OutputHeight) / 2.f);
    target = iIf(Step > 0, target, Options[particle.preference].xy * float2(OutputWidth, OutputHeight));

    particle.velocity = normalize(target - particle.position) * MovementSpeed;

    // Advance by current velocity

    particle.position += particle.velocity;
    Particles[id.x] = particle;
}

// Dissipation kernel
// 
// Dissipates the trails created by the particles during the main simulation.
[numthreads(32,32,1)]
void CSDissipate(uint3 id : SV_DispatchThreadID)
{
    ParticleSpace[id.xy] = 0;
}