#pragma kernel CSSimulate
#pragma kernel CSDissipate

#define CMP <

/** Structures */

//
//  Represents a single particle for the Particle Swarm Optimisation
//  based algorithm.
//
struct Particle
{
    float2 position;
    float2 velocity;
    float2 localBest;
    float2 globalBest;
    float3 color;
};

/** Data */

RWTexture2D<float3>             ParticleSpace;
RWStructuredBuffer<Particle>    Particles;

int OutputWidth;
int OutputHeight;

float W;
float C1;
float C2;
float CommsDistance;


/** Functions */

#include "SolutionSpace.cginc"

float random(in float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

#define R (random(position) * 2.f)

void iterate(inout float2 velocity, in float2 localBest, in float2 position, in float2 globalBest)
{
    velocity = velocity * W + (localBest - position) * C1 * R + (globalBest - position) * C2 * R;
}

#undef R

/** Kernels */

// PSO kernel
// 
// Runs the Particle Swarm Optimisation algorithm.
[numthreads(32,32,1)]
void CSSimulate (uint3 id : SV_DispatchThreadID)
{
    // Gather particle data
    int x = id.x;
    int y = id.y;

    float2 position = Particles[x].position;
    float2 velocity = Particles[x].velocity;


    // Draw particle pixel
    ParticleSpace[position] = Particles[x].color;


    // Modified PSO simulation
    float prevValue = fnSolutionSpace(Particles[x].localBest);
    float bestValue = fnSolutionSpace(Particles[x].globalBest);
    float currValue = fnSolutionSpace(position);

    if (currValue CMP prevValue)
    {
        Particles[x].localBest = position;
    }

    if (currValue CMP bestValue)
    {
        Particles[x].globalBest = position;
    }

    if (length(Particles[y].position - position) < CommsDistance &&
        fnSolutionSpace(Particles[y].globalBest) CMP fnSolutionSpace(Particles[x].globalBest))
    {
        Particles[x].globalBest = Particles[y].globalBest;
    }

    iterate(velocity, Particles[x].localBest, position, Particles[x].globalBest);

    
    // Advance by current velocity
    position += velocity;


    // Apply particle data
    Particles[x].position = position;
    Particles[x].velocity = velocity;
}

// Dissipation kernel
// 
// Dissipates the trails created by the particles during the main simulation.
[numthreads(32,32,1)]
void CSDissipate(uint3 id : SV_DispatchThreadID)
{
    float3 sum = 0;
    int2 uv = (int2)id;

    for (int x = max((uv.x - 1), 0); x < uv.x + 2; x += 1)
    {
        for (int y = max((uv.y - 1), 0); y < uv.y + 2; y += 1)
        {
            sum += ParticleSpace[int2(x, y)];
        }
    }

    ParticleSpace[id.xy] = 0;
}